{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udea9 Fast \u2014 Flag Acquisition and Submission Tool","text":"<p>Fast is a specialized tool built in Python designed for managing exploits and automating flag submission in Attack/Defense (A/D) competitions. The goal of Fast is to take the technical burden off the team players, enabling them to focus on writing exploits and patching vulnerabilities.</p> <p>The development of Fast was heavily influenced by the practical experiences and valuable insights gathered by the Serbian National ECSC Team \ud83c\uddf7\ud83c\uddf8 who utilized the tool in multiple A/D competitions. Fast's development roadmap will continue to be aligned with the team's needs.</p>"},{"location":"#using-the-docs","title":"Using the Docs","text":"<p>This documentation will assist you in getting started with Fast and will also serve as a reference during competitions.</p> <p>If this is your first time using Fast, you can get started with Installation and then proceed to Quickstart to get familiar with the basics. To explore its features or seek help during a competition, refer to the three sections of the User Manual: Server, Dashboard and Client.</p> <p>Good luck and have fun hacking! \ud83c\udf40</p>"},{"location":"install/","title":"Installation","text":"<p>Installing Fast is a straightforward process with no need to clone the repo or manually build the frontend. You can install it in your environment using a single pip command.</p>"},{"location":"install/#installing-via-pip","title":"Installing via pip recommended","text":"<p>To install the latest release, run the following command.</p> LinuxWindows <pre><code>pip install https://github.com/dusanlazic/fast/releases/download/v1.0.0/fast-1.0.0.tar.gz\n</code></pre> <pre><code>pip install https://github.com/dusanlazic/fast/releases/download/v1.0.0/fast-1.0.0.zip\n</code></pre> <p>Older versions can be found on the releases page on GitHub.</p> <p>Tip</p> <p>It's highly recommended to install Fast within a Python virtual environment. This isolates the dependencies and ensures a clean workspace. To create and activate a new Python virtual environment, run the following command:</p> LinuxWindows <pre><code>python3 -m venv venv &amp;&amp; source venv/bin/activate\n</code></pre> <pre><code>python -m venv venv &amp;&amp; .\\venv\\Scripts\\activate\n</code></pre>"},{"location":"install/#installing-from-source","title":"Installing From Source","text":"<p>Fast can also be installed directly from its source. This requires building the frontend with <code>npm</code>.</p> <pre><code>git clone https://github.com/dusanlazic/fast.git\ncd fast/web/\nnpm install\nnpm run build\ncd ../../\npip install -e fast/\n</code></pre>"},{"location":"install/#next-steps","title":"Next Steps","text":"<p>Once the installation is complete, two main commands will be accessible from any directory on your system:</p> <ul> <li><code>fast</code>: For running the client, allowing you to manage and run exploits.</li> <li><code>server</code>: For running the server, used for flag submission and other server-related tasks.</li> </ul> <p>Before running the client or the server, you will need to configure them using YAML files. Fast will always look for the configuration and other relevant files within the current working directory, allowing you to have multiple separate configurations for different competitions. </p> <p>If you are already familiar with the tool, you can move on to Client Configuration if you want to run and manage exploits, or Server Configuration to configure the server.</p> <p>To get familiar with the basics and get Fast running quickly, continue to Quickstart.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>This quickstart guide outlines the minimal steps to get Fast up and running. This includes setting up the database, writing the submitter module, configuring and running a Fast server, configuring a Fast client and running a single exploit.</p> <p>If you are in a competition and your teammate has already configured and launched the server, you can skip to Setting up Fast Client.</p>"},{"location":"quickstart/#setting-up-fast-server","title":"Setting up Fast Server","text":""},{"location":"quickstart/#1-setup-postgres","title":"1. Setup Postgres","text":"<p>The quickest way of setting up a Postgres database is using Docker. Execute the following command on your submitter-dedicated machine to establish a database that works with the default Fast configuration:</p> <pre><code>docker pull postgres:alpine &amp;&amp; docker run --name \"fastdb\" -e POSTGRES_DB=\"fast\" -e POSTGRES_USER=\"admin\" -e POSTGRES_PASSWORD=\"admin\" -p 5432:5432 -d postgres\n</code></pre> <p>Note</p> <p>You can find detailed instructions on configuring the database connection in the User Manual.</p>"},{"location":"quickstart/#2-configure-fast-server","title":"2. Configure Fast Server","text":"<p>After installing Fast on your submitter-dedicated machine, navigate to an empty directory and create a file named <code>server.yaml</code>. An example minimal configuration is as follows:</p> <pre><code>game:\ntick_duration: 80\nflag_format: ENO[A-Za-z0-9+\\/=]{48}\nteam_ip: 10.1.26.1\nsubmitter:\ndelay: 20\n</code></pre> <p>Change the tick duration, flag format (regex pattern) and your vulnbox IP to match your competition requirements. Submitter delay is set to 20 seconds, meaning that flag submission will run 20 seconds after the start of each tick. Feel free to change this value.</p> <p>By default, the server runs on host <code>0.0.0.0</code>, port <code>2023</code>, without a password, and connects to the database set up in the previous step.</p> <p>Note</p> <p>Advanced configuration and every YAML section (<code>game</code>, <code>submitter</code>, <code>server</code> and <code>database</code>) is described in detail in the User Manual.</p>"},{"location":"quickstart/#3-write-the-submitter-module","title":"3. Write the Submitter Module","text":"<p>In the same diretory, create a file named <code>submitter.py</code>. This will be a script that does the actual flag submission. To work properly with Fast, it should follow this simple guideline:</p> <p>The submitter script must define a function named <code>submit</code> that takes a list of flags (as string values) ready for submission. The <code>submit</code> function submits the flags and returns the responses from the flag-checking service as a tuple of two dictionaries: the first dictionary for the accepted flags and the other one for the rejected ones. The keys of the dictionaries are the flags, and the values are the corresponding responses from the flag-checking service.</p> <p>You can adapt the submit function to work with various flag submission mechanisms, such as submitting through a REST API, or over a raw TCP connection. See below for examples.</p> HTTPRaw TCP <pre><code>import requests\ndef submit(flags):\nflag_responses = requests.post('http://example.ctf/flags', json=flags).json()\naccepted_flags = { item['flag']: item['response'] for item in flag_responses if item['response'].endswith('OK') }\nrejected_flags = { item['flag']: item['response'] for item in flag_responses if not item['response'].endswith('OK') }\nreturn accepted_flags, rejected_flags\n</code></pre> <pre><code>from pwn import *\ndef submit(flags):\naccepted_flags, rejected_flags = {}\nr = remote('flags.example.ctf', 1337)\nfor flag in flags:\nr.sendline(flag.encode())\nresponse = r.recvline().decode().strip()\nif response.endswith('OK')\naccepted_flags[flag] = response\nelse:\nrejected_flags[flag] = response\nreturn accepted_flags, rejected_flags\n</code></pre> <p>For a detailed guide on writing exploits, refer to the Submitter Guideline.</p>"},{"location":"quickstart/#4-run","title":"4. Run","text":"<p>In the same directory, run <code>server</code> command.</p> <p>Fast is now ready to receive and submit the flags. By default, Fast server is available on all network interfaces (that includes your local network and your team's VPN) at the port <code>2023</code>.</p> <p>To access the dashboard, navigate to http://localhost:2023 in your web browser. Your teammates will have to use your machine's IP, which may be the one on your team's local network or the public IP if you are running on a VPS.</p> <p>If you are running on a VPS</p> <p>Ensure that your instance is allowed to listen on port <code>2023</code> (or the one that you specified), and that you can connect to the competition's VPN and reach the flag checking service from the VPS. If the limited number of VPN connections is a problem, try this.</p> <p>Also, it's highly recommended to set a password to deter unauthorized access. To set the password, add the following to your <code>server.yaml</code> file:</p> <pre><code>server:\npassword: &lt;custom password&gt;\n</code></pre>"},{"location":"quickstart/#setting-up-fast-client","title":"Setting up Fast Client","text":""},{"location":"quickstart/#1-connect-with-the-server","title":"1. Connect with the Server","text":"<p>After installing Fast on your own (player) machine, navigate to an empty directory and create a file named <code>fast.yaml</code>. </p> <p>The following starter configuration is used for connecting to a Fast server running on host <code>192.168.13.37</code> and port <code>2023</code>. Replace those with the agreed values. Also, change the player name so Fast can distinguish your exploits from those of your teammates.</p> <pre><code>connect:\nhost: 192.168.13.37\nport: 2023\nplayer: yourname\nexploits: # no exploits yet\n</code></pre> <p>Although there are no exploits yet, the configuration above is sufficient for launching Fast client. </p> <p>You can test the connection by running <code>fast</code> in your terminal from the same directory. If everything is OK, the client will start, synchronize with the server, and wait for the exploits. Fast will also alert you that the <code>exploits</code> section is empty, but you can ignore that for now.</p>"},{"location":"quickstart/#2-write-exploits","title":"2. Write Exploits","text":"<p>When managed by Fast, exploit scripts must adhere to a simple guideline to ensure compatibility.</p> <p>Python Scripts: Python exploit scripts should define a function named <code>exploit</code>, taking the target's IP address as the sole parameter. This function must return a text containing one or multiple flags. That's about it, here's a minimal example:</p> <pre><code>import requests\ndef exploit(target):\nreturn requests.get(f'http://{target}:1234/flag').text\n</code></pre> <p>Non-Python Scripts: If you're using non-Python scripts, ensure that the target's IP address can be passed as a command-line argument. The script should only output the text containing one or multiple flags to the standard output (stdout). Here's an example using a Bash script:</p> <pre><code>#!/bin/bash\ncurl -s \"http://$1:1234/flag\"\n</code></pre> <p>Scripts must be placed in the same directory as <code>fast.yaml</code>. Directory may look like this:</p> <pre><code>exploits/\n\u251c\u2500\u2500 alpha.py\n\u251c\u2500\u2500 bravo.py\n\u251c\u2500\u2500 charlie.sh\n\u2514\u2500\u2500 fast.yaml\n</code></pre> <p>For more details on writing the exploits, refer to the Exploit Guideline.</p>"},{"location":"quickstart/#3-manage-exploits","title":"3. Manage Exploits","text":"<p>Once you've written the exploits and stored them in the directory, add them to the <code>exploits</code> section of <code>fast.yaml</code>.</p> <p>Here's the same configuration extended with two example Python scripts and a Bash script:</p> <pre><code>connect:\nhost: 192.168.13.37\nport: 2023\nplayer: yourname\nexploits:\n- name: alpha\ntargets:\n- 10.1.2-11.1\n- name: bravo\ntargets:\n- 10.1.2.1\n- 10.1.6.1\n- 10.1.8-11.1\n- name: charlie\nrun: ./charlie.sh [ip]\ntargets:\n- 10.1.2-11.1\n</code></pre> <p>With this configuration, exploits <code>alpha.py</code>, <code>bravo.py</code> and <code>charlie.sh</code> will be run on the specified range of targets at the beginning of each tick. Every exploit will be run and every target will be attacked at the same time.</p> <p>Any modifications made to the <code>exploits</code> section are automatically applied at the beginning of the next tick, ensuring a seamless integration with ongoing game activities.</p> <p>Note</p> <p>If you are running an executable file directly (e.g., <code>./charlie.sh [ip]</code>), ensure that you have set the execute permission, and you have added an appropriate shebang line (<code>#!/bin/sh</code> or similar) or it's a binary file (e.g., <code>./rust_exploit [ip]</code>).</p>"},{"location":"quickstart/#4-run_1","title":"4. Run","text":"<p>Run <code>fast</code> command from the same directory.</p> <p>Fast client will connect and synchronize with the server. Your exploits will be executed during each tick with the settings specified in your <code>fast.yaml</code>.</p>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<p>You have now successfully completed the Quickstart guide and set up a basic configuration for Fast. For more advanced usage and detailed instructions on how to use Fast effectively during a competition, refer to the sections of the User Manual: Server, Dashboard and Client,</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#addressing-limited-number-of-vpn-connections","title":"Addressing limited number of VPN connections","text":"<p>If you are running the Fast server on a Virtual Private Server (VPS), you might run into issues with reaching the competition infrastructure, such as the flag-checking service essential for flag submission. Event organizers may restrict the number of VPN connections to match the team size, leaving no room for connecting another machine such as your VPS.</p> <p>To address this, you can establish an SSH tunnel, enabling the VPS to route traffic to the flag-checking service using your local machine as a relay.</p> <pre><code>ssh -i /path/to/your/ssh-key.pem -L 5000:10.10.13.37:1337 admin@fast.example.com\n</code></pre> Direct AccessVia SSH Tunnel <pre><code>r = remote('10.10.13.37', 1337)\nrequests.post('http://10.10.13.37:1337/flags', json=flags)\n</code></pre> <pre><code>r = remote('localhost', 5000)\nrequests.post('http://localhost:5000/flags', json=flags)\n</code></pre> <p>In the example scenario above, the flag-checking service is available over the VPN at <code>10.10.13.37:1337</code>. </p> <p>By setting up an SSH tunnel, traffic directed to <code>localhost:5000</code> on the VPS is forwarded to <code>10.10.13.37:1337</code>. This tunneling ensures bidirectional communication, allowing both sending flags and receiving the responses.</p>"},{"location":"user-manual/client/configuration/","title":"Fast Client Overview","text":"<p>Client configuration is managed using a YAML file named <code>fast.yaml</code>. Fast looks for the configuration file and exploit scripts in the current working directory. This allows having multiple separate configurations and environments for different competitions.</p> <p>The <code>fast.yaml</code> file is composed of two sections, one for configuring the connection with the server, and one for exploit management. This page focuses on the first section. If you are looking for exploit management, see Exploit Management page.</p>"},{"location":"user-manual/client/configuration/#connecting","title":"Connecting","text":"<p>To setup Fast client for connecting to the server, you need to specify your server's host, port, password (if required), and your custom username.</p> <p>Some starter <code>fast.yaml</code> configurations with no managed exploits are shown below:</p>"},{"location":"user-manual/client/configuration/#examples","title":"Examples","text":"Minimum Team ConfigCustomized PortPassword AuthPublic ServerSingle Player <pre><code>connect:\nhost: 192.168.13.37\nplayer: john\nexploits:\n</code></pre> <pre><code>connect:\nhost: 192.168.13.37\nport: 80\nplayer: john\nexploits:\n</code></pre> <pre><code>connect:\nhost: 192.168.13.37\npassword: Noflags4you!\nplayer: john\nexploits:\n</code></pre> <pre><code>connect:\nhost: fast.example.com\npassword: Noflags4you!\nplayer: john\nexploits:\n</code></pre> <pre><code># Omit to connect to localhost:2023 with no password\nexploits:\n</code></pre> <p>Although the shown examples have no managed exploits, every given configuration is sufficient for launching the client.</p> <p>You can test the connection by running <code>fast</code> in your terminal from the same directory. If everything is OK, the client will start, synchronize with the server, and wait for exploits. </p>"},{"location":"user-manual/client/configuration/#options","title":"Options","text":"<p>This section starts with the keyword <code>connect:</code> placed anywhere at the root level of the file.</p> <code>host</code> default = <code>localhost</code> Host address of the Fast server. By default, client will connect to a Fast server running on localhost. <code>port</code> default = <code>2023</code> Port number on which the Fast server is listening. Default is <code>2023</code>. <code>player</code> default = <code>anon</code> Your name or alias to help Fast distinguish your exploits from those of your teammates. <code>password</code> default = <code>None</code> Password for authenticating with the Fast server."},{"location":"user-manual/client/configuration/#next-steps","title":"Next Steps","text":"<p>To learn how to start running and managing exploits, read the Exploit Guideline and then continue to Exploit Management.</p>"},{"location":"user-manual/client/exploit-guideline/","title":"Exploit Guideline","text":"<p>Fast is built around exploits, making them the central component when it comes to attacking the opponent teams. The \"Flag Acquisition\" part of Fast is done by the exploits written by you and your team. To work properly with Fast, exploit scripts must be placed in the same directory as <code>fast.yaml</code> and follow the simple guideline specified below.</p>"},{"location":"user-manual/client/exploit-guideline/#python-exploits","title":"Python Exploits","text":""},{"location":"user-manual/client/exploit-guideline/#structure","title":"Structure","text":"<p>A Python exploit script must define a function named <code>exploit</code>, taking the target's IP address as the sole parameter. This function is responsible for exploiting the service, and it returns a string containing one or multiple flags. That's about it, here's a minimal example:</p> <pre><code>import requests\ndef exploit(target):\nreturn requests.get(f'http://{target}:1234/flag').text\n</code></pre>"},{"location":"user-manual/client/exploit-guideline/#template","title":"Template","text":"<p>If you like type hints, you can use the following template.</p> <pre><code>def exploit(target: str) -&gt; str:\n# Exploit the target, get the flags\nreturn text_containing_flags\n</code></pre>"},{"location":"user-manual/client/exploit-guideline/#prepare-and-cleanup","title":"Prepare and Cleanup","text":"<p>Some A/D competitions include an endpoint that provides you with additional pieces of information that may be necessary to exploit particular services. This typically includes something like the username of the account that can read the flag, some useful filename, etc.</p> <p>This data could be fetched only once and be reused for all the targets, saving both bandwidth and memory. For this kind of tasks, you can define the <code>prepare</code> function in your script, which will be invoked by Fast once before exploiting any of the targets.</p> <pre><code>import requests\nshared = {}\ndef prepare():\nattack_json = requests.get('https://example.ctf/attack.json').json()\nshared['attack_json'] = attack_json\ndef exploit(target):\nusername = shared['attack_json'][target]['example_service']['username']\nreturn requests.get(f'http://{target}:1337/readflag?username={username}').text\n</code></pre> <p>The <code>prepare</code> function in the shown example fetches the data and stores it in a global variable, as a way of preparing the environment before exploiting the services.</p> <p>On the opposite end, you can define a function named <code>cleanup</code> for performing any needed post-exploitation actions. As the name suggests, it may be used for removing the residual files your exploit may create or download.</p> <pre><code>import os, glob\n# exploit and prepare omitted for brevity\ndef cleanup():    \nfor file in glob.glob('files/alpha/*.pdf'):\nos.remove(file)\n</code></pre> <p>The <code>cleanup</code> function in the shown example removes all PDF files downloaded by the exploit.</p> <p>Note</p> <p>Prepare and cleanup actions can also be defined as shell commands in <code>fast.yaml</code>. This way is less powerful since it provides no access to the shared interpreter, but it's compatible with non-Python exploits. Consult the Exploit Management page for more details.</p>"},{"location":"user-manual/client/exploit-guideline/#non-python-exploits","title":"Non-Python Exploits","text":""},{"location":"user-manual/client/exploit-guideline/#structure_1","title":"Structure","text":"<p>When it comes to non-Python scripts, ensure that the target's IP address can be passed as a command-line argument. The script should only output the text containing one or multiple flags to the standard output (stdout). Here's an example using a Bash script:</p> <pre><code>#!/bin/bash\ncurl -s \"http://$1:1234/flag\"\n</code></pre>"},{"location":"user-manual/client/exploit-guideline/#next-steps","title":"Next steps","text":"<p>Once you have a new exploit ready, you can hand it to Fast to start running it. To learn how to manage exploits and see what capabilities Fast offers, continue to Exploit Management.</p>"},{"location":"user-manual/client/exploit-management/","title":"Exploit Management","text":"<p>This page dives into the details of exploit management within Fast. Serving both as a comprehensive reference and a practical guide, this page illustrates the capabilities of Fast through examples, and explains how and when to utilize them.</p>"},{"location":"user-manual/client/exploit-management/#overview","title":"Overview","text":""},{"location":"user-manual/client/exploit-management/#introduction","title":"Introduction","text":"<p>All exploit management takes place in the <code>exploits</code> section of <code>fast.yaml</code>.</p> <pre><code>connect:\nhost: 192.168.13.37\nport: 2023\nplayer: yourname\nexploits:\n- name: alpha\ntargets:\n- 10.1.2-11.1\n- name: bravo\ntargets:\n- 10.1.2-11.1\n</code></pre> <p>This file is designed to be continuously updated throughout the game. Any modifications made to the <code>exploits</code> section are automatically applied at the beginning of the next tick, ensuring a seamless integration with ongoing game activities.</p> <p>If you accidentally write an invalid configuration (bad formatting, accidental save, etc.), Fast will reuse the last working configuration until you fix it. The error messages related to your configuration will be logged to the console.</p>"},{"location":"user-manual/client/exploit-management/#how-it-works","title":"How It Works","text":"<p>The only two fields required to start running a Python exploit are <code>name</code> and <code>targets</code>. </p> <p>Fast runner will look for the module in the current working directory with the same name (module name, not filename) and import it dynamically. A \"runner\" is a child process responsible for running a single exploit, ensuring that each exploit gets its own separate interpreter and it bypasses the main process's Global Interpreter Lock (GIL).</p> <p>Since exploits are typically I/O bound tasks, runners utilize threading to run the exploit on multiple targets at once. To sum up, each exploit gets its own process/interpreter, and each target get its own thread within that process.</p> <p>For non-Python exploits it's a bit different since a non-Python script cannot be imported into Python. Instead of a thread, Fast runner will start a subprocess for each target, running shell commands provided in the <code>run</code> field.</p>"},{"location":"user-manual/client/exploit-management/#basic-minimal-example","title":"Basic Minimal Example","text":"PythonNon-Python <pre><code>- name: alpha\ntargets:\n- 10.1.2-11.1\n</code></pre> <pre><code>- name: alpha\nrun: bash alpha.sh [ip] targets:\n- 10.1.2-11.1\n</code></pre>"},{"location":"user-manual/client/exploit-management/#usage","title":"Usage","text":""},{"location":"user-manual/client/exploit-management/#specifying-targets","title":"Specifying Targets","text":"<p>IP addresses can be listed individually, and IP ranges can be expressed using hyphens.</p> <pre><code>- name: alpha\ntargets:\n- 10.1.3.1\n- 10.1.5.1\n- 10.1.7-10.1\n</code></pre> <p>About the Example</p> <p>At the beginning of each tick Fast will concurrently run the exploit alpha on the following targets:</p> <ul> <li>10.1.3.1, 10.1.5.1, 10.1.7.1, 10.1.8.1, 10.1.9.1, 10.1.10.1.</li> </ul>"},{"location":"user-manual/client/exploit-management/#customizing-exploit-name","title":"Customizing Exploit Name","text":"<p>You can set a custom exploit name that will be shown in the logs and on the web dashboard. Simply change the value of the <code>name</code> field, and set the <code>module</code> field to the actual name of your Python module.</p> <pre><code>- name: bravo v2\nmodule: bravo\ntargets:\n- 10.1.2-11.1\n- name: charlie\nmodule: charlie3_Final_fixed\ntargets:\n- 10.1.2-11.1\n</code></pre> <p>This field is mandatory when running a non-Python exploit.</p> <pre><code>- name: delta\nrun: bash delta [ip]\ntargets:\n- 10.1.2-11.1\n</code></pre>"},{"location":"user-manual/client/exploit-management/#running-a-non-python-exploit","title":"Running a Non-Python Exploit","text":"<p>To run a non-Python exploit, set the <code>run</code> field to a shell command used for running the exploit. Ensure that the target's IP address can be passed as a command-line argument to your exploit. In your provided command, use <code>[ip]</code> as a placeholder for the actual IP address.</p> <pre><code>- name: delta\nrun: bash delta.sh [ip]\ntargets:\n- 10.1.2-5.1\n</code></pre> <p>About the example</p> <p>At the beginning of each tick Fast will run the following commands in parallel: <pre><code>bash delta.sh 10.1.2.1\nbash delta.sh 10.1.3.1\nbash delta.sh 10.1.4.1\nbash delta.sh 10.1.5.1\n</code></pre></p> <p>Exploits written in other languages are handled the same way:</p> <pre><code>node exploit.js [ip]\nbash exploit.sh [ip]\njava -jar exploit.jar [ip]\ndotnet exploit.dll [ip]\nruby exploit.rb [ip]\nperl exploit.pl [ip]\nphp exploit.php [ip]\n./rust_exploit [ip]\n./exploit.sh [ip]\n</code></pre> <p>If you are running an executable file directly (e.g., <code>./exploit.sh [ip]</code>), ensure that you have set the execute permission, and you have added an appropriate shebang line (<code>#!/bin/sh</code> or similar) or it's a binary file (e.g., <code>./rust_exploit [ip]</code>).</p>"},{"location":"user-manual/client/exploit-management/#timeout-alerts","title":"Timeout Alerts","text":"<p>The <code>timeout</code> field allows you to specify a duration in seconds within you expect an exploit to complete its run against a single target. If the exploit takes longer than the specified timeout, Fast will print an alert in the console.</p> <p>Please note that in the current version, Fast does not have the capability to terminate exploits that exceed the specified timeout. It is advisable to incorporate timeouts within your exploit code where applicable, such as using the <code>timeout</code> parameter in the <code>requests</code> library.</p> <pre><code>- name: echo\ntimeout: 15\ntargets:\n- 10.1.2-11.1\n</code></pre>"},{"location":"user-manual/client/exploit-management/#environment-variables","title":"Environment Variables","text":"<p>Environment variables can be set for each exploit using the <code>env</code> field. Environment variables are passed as key-value pairs. This is useful if you need to make your exploit configurable, or run the same exploit with different parameters for different targets.</p> <pre><code>- name: foxtrot\nenv:\nWEBHOOK: https://webhook.site/748d0bd3-1764-4498-9d3a-b958b04b52a2\nACCESS_TOKEN: Ku+j13dEIuXcAZQr2kYFgP/6Xvw=\ntargets:\n- 10.1.2-11.1\n</code></pre>"},{"location":"user-manual/client/exploit-management/#prepare-and-cleanup","title":"Prepare and Cleanup","text":"<p>The <code>prepare</code> and <code>cleanup</code> fields allow you to define shell commands to be executed before and after the exploit finishes running on all specified targets, respectively.</p> <pre><code>- name: golf\nprepare: &gt;\nwget https://example.ctf/attack.json -o golf.json\njq -i '{ availableTeams: .availableTeams, services: { golfapp: .services.golfapp } }' golf.json\ncleanup: rm golf.json\ntargets:\n- 10.1.2-11.1\n</code></pre> <p>About the Example</p> <p>Before running the exploit, Fast will run the command provided in the <code>prepare</code> field, which will download the <code>attack.json</code> file and modify it in-place using <code>jq</code>.</p> <p>After the exploit is done with all the targets, Fast will run the command provided in the <code>cleanup</code> field, removing the file to keep the workspace clean.</p> <p>Hacker Tip</p> <p>For Python exploits, a more powerful and flexible approach is to use <code>prepare()</code> and <code>cleanup()</code> Python functions within your exploit code, as they have full access to your exploit script. More details can be found in the Exploit Guideline.</p>"},{"location":"user-manual/client/exploit-management/#optimizing-with-delays","title":"Optimizing with Delays","text":"<p>In situations where running multiple exploits simultaneously can lead to huge spikes in CPU, memory and network usage, Fast offers the <code>delay</code> attribute for setting a delay in seconds before the exploit's execution begins, relative to the start of the tick. This allows you to strategically arrange your exploits, distribute the load over time, and reduce the risk of overloading your system resources.</p> <pre><code>- name: hotel\ntargets:\n- 10.1.2-31.1\n- name: india\ndelay: 5\ntargets:\n- 10.1.2-31.1\n- name: juliett\ndelay: 10\ntargets:\n- 10.1.2-31.1\n</code></pre> <p>About the Example</p> <p>At the beginning of each tick Fast will run the exploit hotel at 30 targets. 5 seconds later it will run india, and after 5 more seconds it will run juliett. Assuming that none of these exploits take more than 5 seconds (exploits typically take much less), the peak number of concurrent attacks will be no more than 30, rather than up to 90.</p> <p></p>"},{"location":"user-manual/client/exploit-management/#optimizing-with-batching","title":"Optimizing with Batching","text":"<p>Batching is another way of distributing the load over time with the goal of mitigating CPU, memory and network usage spikes. Setting up batching allows you to divide the list of targets into smaller, equally-sized and more manageable batches.</p> <p>To enable batching, you need to set either the number of batches (<code>count</code>), or the size of each batch (<code>size</code>):</p> <ul> <li><code>count</code>: Specifies the total number of equal-sized batches the targets will be divided into.</li> <li><code>size</code>: Specifies the size of each batch. Number of batches will be calculated.</li> </ul> <p>The <code>wait</code> attribute defines the time gap in seconds between processing two consecutive batches. </p> Batch by CountBatch by Size <pre><code>- name: kilo\nbatches:\ncount: 5  # Will form batches of sizes [6, 6, 6, 6, 6]\nwait: 2\ntargets:\n- 10.1.2-31.1\n</code></pre> <pre><code>- name: kilo\nbatches:\nsize: 8  # Will form batches of sizes [8, 8, 8, 6]\nwait: 2\ntargets:\n- 10.1.2-31.1\n</code></pre> <p>About the Example</p> <p>At the beginning of each tick Fast will run the exploit on the first batch of targets, then wait for 2 seconds before running the next batch, repeating until it's done with all the targets.</p> <p></p> <p>Hacker Tip</p> <p>If you are using batching on multiple exploits, set different delays for each exploit to prevent the batches from overlapping. This will eliminate the \"stacked spikes\" you may create from batching.</p> <pre><code>- name: lima\nbatches:\ncount: 5\nwait: 3\ntargets:\n- 10.1.2-31.1\n- name: mike\ndelay: 2\nbatches:\nsize: 8\nwait: 3\ntargets:\n- 10.1.2-31.1\n</code></pre> <p></p>"},{"location":"user-manual/client/overview/","title":"Fast Client Configuration","text":"<pre><code>    graph LR\n\n        client[Fast client] --&gt;|spawns&lt;br/&gt;subprocess| alpha[\"runner\"]\n        client[Fast client] --&gt;|spawns&lt;br/&gt;subprocess| bravo[\"runner\"]\n\n        subgraph \"Exploit Alpha\"\n            alpha --&gt;|spawns&lt;br/&gt;thread| alphaThread1[\"exploit(10.1.2.1)\"]\n            alpha --&gt;|spawns&lt;br/&gt;thread| alphaThread2[\"exploit(10.1.3.1)\"]\n            alpha --&gt;|spawns&lt;br/&gt;thread| alphaThread3[\"exploit(10.1.4.1)\"]\n        end\n\n        subgraph \"Exploit Bravo\"\n            bravo --&gt;|spawns&lt;br/&gt;thread| bravoThread1[\"exploit(10.1.2.1)\"]\n            bravo --&gt;|spawns&lt;br/&gt;thread| bravoThread2[\"exploit(10.1.3.1)\"]\n            bravo --&gt;|spawns&lt;br/&gt;thread| bravoThread3[\"exploit(10.1.4.1)\"]\n        end\n\n        subgraph \"Opponents'&lt;br/&gt;&amp;nbsp;&amp;nbsp;services\"\n            target1[10.1.2.1]\n            target2[10.1.3.1]\n            target3[10.1.4.1]\n        end\n\n        alphaThread1 --&gt;|attacks| target1\n        alphaThread2 --&gt;|attacks| target2\n        alphaThread3 --&gt;|attacks| target3\n\n        bravoThread1 --&gt;|attacks| target1\n        bravoThread2 --&gt;|attacks| target2\n        bravoThread3 --&gt;|attacks| target3</code></pre> <p>Anyone on the team can run a separate Fast client on their own machine. Each client's primary role is to run the exploits according to the user's specification. Fast provides an intuitive way of configuring using a single YAML file. That includes specifying targets, customizing each exploit's environment, and strategic arrangement of the attacks to ensure optimal CPU, memory and network resource utilization.</p> <p>The core functionality of Fast is to run the attacks concurrently and independently of each other. If an exploit crashes or timeouts on one target, its execution on the other targets will remain unaffected. This is achieved by using threading library, spawning a separate Python thread for each target. </p> <p>Exploits are ran separately as subprocesses. This lets attacks of the same exploit share the same Python interpreter, enabling the use of <code>prepare</code> and <code>cleanup</code> functions in your exploit code, as well as bypassing the main process's Global Interpreter Lock (GIL).</p> <p>Additionally, all clients will conform to the flag format specified on the server and synchronize with the server's tick clock, making them remain in sync without any time drifts or offsets.</p> <p>This documentation section covers client configuration, exploit development guideline, and exploit management. Real-world examples complement each topic. You can use this documentation both as a guide during setup and as a reference in a competition.</p>"},{"location":"user-manual/client/running/","title":"Running Fast Client","text":"<p>Before running Fast client, ensure the following:</p> <ul> <li> The server is up: You or someone on your team has configured and started the server.</li> <li> You can access the dashboard: Open the dashboard to confirm your machine can access the Fast server. Ask your teammates for host, port, and password.</li> <li> Client is configured: You have configured the client and the configuration file (<code>fast.yaml</code>) is located in your current working directory.</li> </ul> <p>To run the client, just run the command <code>fast</code>.</p> <p>Fast client will start, connect and synchronize with the server. It will wait for the next tick to begin before it starts running your exploits. You can open the dashboard to monitor the tick clock and wait for your flags to show up.</p> <p>That's it. Good luck and have fun hacking! \ud83c\udf40</p>"},{"location":"user-manual/dashboard/browser/","title":"Flag Browser","text":"<p>The flag browser offers a way to search for flags using a simple, user-friendly, and flexible query language. Being able to efficiently browse flags enchances transparency and allows various useful insights, such as checking how your newly added exploit behaves, identifying affected targets, discovering problems early, and many more.</p>"},{"location":"user-manual/dashboard/browser/#query-language","title":"Query Language","text":"<p>The query language provides a powerful way to filter and search flags based on various criteria. It is designed to be flexible and intuitive, using symbols and keywords that resemble both natural language and common programming syntax. </p> <p>Below you will find a comprehensive list of symbols and keywords, along with examples. These are provided as an aid for using the query language. It's recommended to play around with the flag browser to become familiar with its functionality, and refer to this guide when needed.</p> <p>Note</p> <p>All keywords are case-insensitive.</p>"},{"location":"user-manual/dashboard/browser/#comparison-operators","title":"Comparison Operators","text":"<pre><code>player is s4ndu\ntarget = \"10.1.3.1\"\ntick &gt;= 30\ntimestamp after 16:00\ntick between 5 and 30\ntick between [5, 30]\ntimestamp between 16:00 and 16:10\n</code></pre> <ul> <li>Equal to (<code>==</code>, <code>=</code>, <code>equals</code>, <code>eq</code>, <code>is</code>)</li> <li>Not equal to (<code>!=</code>, <code>&lt;&gt;</code>, <code>not equals</code>, <code>ne</code>, <code>is not</code>)</li> <li>Greater than (<code>&gt;</code>, <code>gt</code>, <code>over</code>, <code>above</code>, <code>greater than</code>)</li> <li>Less than (<code>&lt;</code>, <code>lt</code>, <code>under</code>, <code>below</code>, <code>less than</code>)</li> <li>Greater or equal to (<code>&gt;=</code>, <code>ge</code>, <code>min</code>, <code>not under</code>, <code>not below</code>, <code>after</code>)</li> <li>Less or equal to (<code>&lt;=</code>, <code>le</code>, <code>max</code>, <code>not over</code>, <code>not above</code>, <code>before</code>)</li> <li>Between (<code>between</code>)</li> </ul>"},{"location":"user-manual/dashboard/browser/#string-matching","title":"String Matching","text":"<pre><code>response matches \".* OK\"\ntarget contains 10.10.\nvalue starts with \"FAST{\"\nresponse ending with OK\n</code></pre> <ul> <li>Matches regex pattern (<code>matches</code>, <code>matching</code>, <code>regex</code>)</li> <li>Contains substring (<code>contains</code>, <code>containing</code>)</li> <li>Starts with substring (<code>starts with</code>, <code>starting with</code>, <code>begins with</code>, <code>beginning with</code>)</li> <li>Ends with substring (<code>ends with</code>, <code>ending with</code>)</li> </ul>"},{"location":"user-manual/dashboard/browser/#in-and-not-in","title":"In and Not In","text":"<pre><code>status in [accepted, rejected]\nexploit not in [alpha, bravo]\nplayer of [alice, bob]\nplayer not of ['alice', 'bob']\n</code></pre> <ul> <li>Contained in (<code>in</code>, <code>of</code>)</li> <li>Not contained in (<code>not in</code>, <code>not of</code>)</li> </ul>"},{"location":"user-manual/dashboard/browser/#describing-timestamps","title":"Describing Timestamps","text":"<p>Note</p> <p>The today's date is assumed when searching by timestamp.</p> <pre><code>16:00, 16.00, 16-00, 16:00:45, 09:20, 9:20\n5 mins ago, 1 hour ago, 5 hour ago, 20 seconds ago\n</code></pre> <ul> <li>Seconds ago (<code>s</code>, <code>sec</code>, <code>second</code>, <code>seconds</code>) + <code>ago</code></li> <li>Minutes ago (<code>m</code>, <code>min</code>, <code>mins</code>, <code>minute</code>, <code>minutes</code>) + <code>ago</code></li> <li>Hours ago (<code>h</code>, <code>hour</code>, <code>hours</code>) + <code>ago</code></li> </ul>"},{"location":"user-manual/dashboard/browser/#logical-operators","title":"Logical Operators","text":"<p>You can combine multiple search criteria using logical operators, with a precedence order of \"<code>NOT</code>, <code>AND</code>, <code>OR</code>.\" Parentheses can be used to override this precedence and can be nested, allowing highly customizable queries.</p> <pre><code>player is s4ndu and exploit is alpha\nstatus == accepted &amp;&amp; (exploit == alpha || target == 10.1.4.1)\nexploit is alpha or (target is 10.1.4.1 and (timestamp &lt; 16:00 or timestamp &gt; 18:00))\n</code></pre> <ul> <li>Conjunction (<code>and</code>, <code>&amp;</code>, <code>&amp;&amp;</code>, <code>,</code>)</li> <li>Disjunction (<code>or</code>, <code>|</code>, <code>||</code>)</li> <li>Negation (<code>not</code>, <code>~</code>, <code>!</code>)</li> </ul>"},{"location":"user-manual/dashboard/dashboard/","title":"Dashboard","text":"<p>The dashboard provides real-time insights into exploits' performance during the current tick, reflects the state of the flags in the database, and displays the number of accepted flags for each exploit over the last ten ticks. </p> <p>Status icons portray the condition of each exploit, with a distinct \"bug\" icon signaling when an exploit impacts one of your own services, alerting the team to patch the service.</p> <p>Two countdowns tell the time remaining until the next tick and the next flag submission, along with the progress bar on top that represents the progression of the current tick.</p>"},{"location":"user-manual/dashboard/manual/","title":"Manual Submitter","text":"<p>The Manual Submitter serves as a tool for submitting flags manually when you have the flags but not the exploit ready yet. It provides a text area where you can paste any content, such as HTTP response data containing one or multiple flags. After you paste the text, the flags will be matched using regex.</p> <p>The manual submitter offers two actions for handling matched flags:</p> <ul> <li>Queue the flags: You can push the flags to the submission queue and wait for them to be submitted in the next scheduled submit.</li> <li>Submit immediately: Alternatively, you can submit right away and get immediate results.</li> </ul> <p>The actual flag submission is handled by your submitter module. You can also manually submit dummy flags to ensure that the submitter module is functioning properly.</p>"},{"location":"user-manual/dashboard/overview/","title":"Flag Dashboard Overview","text":"<p>Fast comes with an intuitive web interface for monitoring and evaulating the performance of all running exploits during an A/D competition. You can track your exploits' performance in real-time, browse the flags using a simple yet flexible query language, and submit new flags manually.</p> <p>To access the dashboard, navigate to <code>http://&lt;Fast Server Host&gt;:&lt;Fast Server Port&gt;/</code> in your web browser. If Basic Auth is enabled, the browser will prompt you for the credentials (username can be set to anything).</p> <p>The interface consists of three views:</p> <ul> <li>Dashboard</li> <li>Flag Browser</li> <li>Manual Submitter</li> </ul>"},{"location":"user-manual/server/configuration/","title":"Fast Server Configuration","text":"<p>Server configuration is stored inside a YAML file named <code>server.yaml</code>. Fast looks for the configuration file within the current working directory. This allows having multiple separate configurations and environments for different competitions.</p> <p>The <code>server.yaml</code> file is composed of multiple sections, each used for configuring different aspects of the tool. These sections are described in detail below.</p>"},{"location":"user-manual/server/configuration/#game-settings","title":"Game Settings required","text":"<p>The <code>game</code> section includes game-related settings that should match the competition's requirements and your team's properties within the competition. This configuration is retrieved by the clients, allowing them to extract flags based on the flag format and synchronize the attacks with the server's tick timing. This way you have to configure only the server, while the clients will automatically configure themselves upon connecting.</p>"},{"location":"user-manual/server/configuration/#examples","title":"Examples","text":"<p>a. Complete configuration</p> <pre><code>game:\ntick_duration: 80\nflag_format: ENO[A-Za-z0-9+\\/=]{48}\nteam_ip: 10.1.26.1\n</code></pre> About the Example <p>Exploits will reload and rerun every 80 seconds, flags will be collected using the given regex, and alerts will appear on the dashboard each time an exploit retrieves a flag from your own service (target <code>10.1.26.1</code>).</p>"},{"location":"user-manual/server/configuration/#options","title":"Options","text":"<p>The section starts with the keyword <code>game:</code> placed anywhere at the root level of the file.</p> <code>tick_duration</code> required <p>Tick duration in seconds. The duration is given by the competition organizers.</p> <code>flag_format</code> required <p>Regex pattern for flag matching. The pattern is given by the competition organizers. Knowing the pattern allows the clients to extract flags from exploit scripts' return values.</p> <code>team_ip</code> required <p>Your team's IP address. Fast will not submit flags originating from this IP. Instead, it will trigger an alert on the dashboard indicating that your exploit affects your own service and immediate patching is required.</p> <p>To specify multiple IP addresses (e.g. for Ubuntu, Fedora and Windows machines), use a list like <code>[10.1.26.1, 10.1.26.2, 10.1.26.3]</code>.</p>"},{"location":"user-manual/server/configuration/#submitter","title":"Submitter required","text":"<p>The <code>submitter</code> section is used for configuring the delay and optionally the module used for flag submission. The submitter module (default <code>submitter.py</code>) must be placed in the current working directory. For more details on writing this module, read the Submitter Guideline.</p>"},{"location":"user-manual/server/configuration/#examples_1","title":"Examples","text":"<p>a. Minimal</p> <pre><code>submitter:\ndelay: 20\n</code></pre> About the Example <p>Flags will be submitted 20 seconds after the beginning of each tick using the <code>submitter.py</code> script placed in the same directory.</p> <p>b. Setting a custom module name</p> <pre><code>submitter:\ndelay: 20\nmodule: ecsc_submitter_v2\n</code></pre> About the Example <p>Flags will be submitted 20 seconds after the beginning of each tick using the <code>ecsc_submitter_v2.py</code> script placed in the same directory.</p>"},{"location":"user-manual/server/configuration/#options_1","title":"Options","text":"<p>The section starts with the keyword <code>submitter:</code> placed anywhere at the root level of the file.</p> <code>delay</code> required <p>Number of seconds to wait before submitting the flags. The time is relative to the beginning of the tick.</p> <p>Hint</p> <p>Choose a value based on the estimated time it takes for all your exploits to complete. Try not to submit too early or too late.</p> <code>module</code> default = <code>submitter</code> <p>Custom name of your submitter module. Omit this field if your submitter module is named <code>submitter.py</code>; otherwise, name it to match its module name (without .py extension).</p>"},{"location":"user-manual/server/configuration/#server","title":"Server","text":"<p>The <code>server</code> section is used for configuring the gevent server Fast runs on. That includes configuring the host, port, and the password.</p> <p>These settings must be shared with everyone on the team running Fast clients, allowing them to configure the necessary connection parameters.</p> <p>Omitting this section results in using the default settings, making the server available on port <code>2023</code> with no password required.</p>"},{"location":"user-manual/server/configuration/#examples_2","title":"Examples","text":"<p>a. Running on a custom port and setting the HTTP Basic Auth password</p> <pre><code>server:\nport: 80\npassword: Noflags4you!\n</code></pre> About the Example <p>Fast server will run on the port 80 and will require a password for connecting and accessing the web dashboard.</p>"},{"location":"user-manual/server/configuration/#options_2","title":"Options","text":"<p>The section starts with the keyword <code>server:</code> placed anywhere at the root level of the file.</p> <code>host</code> default = <code>0.0.0.0</code> <p>Host address on which the server will run. By default, it will listen on all available network interfaces.</p> <code>port</code> default = <code>2023</code> <p>Port number on which the server will accept connections. Default is <code>2023</code>.</p> <code>password</code> default = <code>None</code> <p>Enables HTTP Basic Authentication and sets the password for Fast clients and web dashboard. Omit this field to disable password authentication. It's highly recommended to set a password to deter unauthorized access, especially if your server is publicly accessible (e.g. running on a VPS).</p>"},{"location":"user-manual/server/configuration/#database-connection","title":"Database Connection","text":"<p>The <code>database</code> section is used for configuring the parameters for connecting to the Postgres database used for storing flags. This includes the database name, user, password, host, and port. </p> <p>Omitting this section results in using the default values, making Fast connect to a database named <code>fast</code> on <code>localhost:5432</code> with the credentials <code>admin:admin</code>. </p> <p>You can execute the following command to spin up a \"default\" database locally using Docker:</p> <pre><code>docker pull postgres:alpine &amp;&amp; docker run --name \"fast_database_container\" -e POSTGRES_DB=\"fast\" -e POSTGRES_USER=\"admin\" -e POSTGRES_PASSWORD=\"admin\" -p 5432:5432 -d postgres\n</code></pre> <p>You can use the same command to run Postgres Docker image with different variables. The database may be hosted on the same machine or on a separate server, depending on your preference and setup requirements.</p>"},{"location":"user-manual/server/configuration/#examples_3","title":"Examples","text":"<p>a. Setting database name and credentials</p> <pre><code>database:\nname: fast_db_2023\nuser: cyberhero\npassword: zU189&amp;63!Ixq\n</code></pre> About the Example <p>Fast server will connect to a database named <code>fast_db_2023</code> running on <code>localhost</code> at port <code>5432</code>, with the credentials <code>cyberhero:zU189&amp;63!Ixq</code>.</p>"},{"location":"user-manual/server/configuration/#options_3","title":"Options","text":"<p>The section starts with the keyword <code>database:</code> placed anywhere at the root level of the file.</p> <code>name</code> default = <code>fast</code> Name of the database. <code>user</code> default = <code>admin</code> Username for authenticating with the database. <code>password</code> default = <code>admin</code> Password for authenticating with the database. <code>host</code> default = <code>localhost</code> Host address of the database server. By default, Fast will connect to a database running on localhost. <code>port</code> default = <code>5432</code> Port number on which the database server is listening. Default is <code>5432</code>, same as the Postgres default."},{"location":"user-manual/server/overview/","title":"Fast Server Overview","text":"<pre><code>    graph LR\n\n        targets[\"Opponents'&lt;br/&gt;services\"]\n        targets --&gt; aliceExploits[Alice's exploits]\n        targets --&gt; bobExploits[Bob's exploits]\n        targets --&gt; carolExploits[Carol's exploits]\n\n        subgraph \"Alice's machine\"\n            aliceExploits --&gt; client1[Alice's client]\n        end\n\n        subgraph \"Bob's machine\"\n            bobExploits --&gt; client2[Bob's client]\n        end\n\n        subgraph \"Carol's machine\"\n            carolExploits --&gt; client3[Carol's client]\n        end\n\n        client1 --&gt;|extracts &amp;&lt;br/&gt;forwards flags| server[Fast server]\n        client2 --&gt;|extracts &amp;&lt;br/&gt;forwards flags| server\n        client3 --&gt;|extracts &amp;&lt;br/&gt;forwards flags| server\n\n        server --&gt;|submits| flagService[Flag-checking service]</code></pre> <p>Fast server is responsible for collecting and submitting flags, filtering out duplicates, providing useful insights through the dashboard, and keeping all the connected clients in sync. It's designed to operate under heavy load conditions and implements measures for quick and easy recovery if anything goes wrong.</p> <p>This section provides instructions for configuring the Fast server and writing the submitter. It includes real-world examples and details every option in the configuration YAML. You can use this documentation both as a guide during setup and as a reference in a competition.</p>"},{"location":"user-manual/server/running/","title":"Running Fast Server","text":"<p>Before running Fast server, ensure the following:</p> <ul> <li> Server is configured: You have configured the server and the configuration file (<code>server.yaml</code>) is located in your current working directory.</li> <li> Submitter module is written: You have written the submitter module according to the Submitter Guideline and it's located in your current working directory.</li> </ul> <p>To run the server, just run the command <code>server</code>.</p> <p>The Fast server is now ready to receive and submit flags. </p> <p>To access the dashboard, navigate to http://localhost:2023 in your web browser. Your teammates will have to use your machine's IP, which may be the one on your team's local network or the public IP if you are running on a VPS. Verify with your teammates that they can access the dashboard with no issues.</p>"},{"location":"user-manual/server/submitter-guideline/","title":"Submitter Guideline","text":"<p>The submitter module is a vital part of Fast, responsible for the actual submission of flags to the competition's flag-checking service. Fast is adaptable to any A/D competition because it lets you write this module yourself. To work properly with Fast, your submitter script must follow the simple guideline specified below.</p>"},{"location":"user-manual/server/submitter-guideline/#structure-of-the-submitter-module","title":"Structure of the Submitter Module","text":"<p>The submitter script must define a function named <code>submit</code> that takes a list of flags (as string values) ready for submission. This function is responsible for submitting the flags to the flag-checking service and collecting the responses.</p> <p>The <code>submit</code> function returns a tuple of two dictionaries:</p> <ol> <li>Accepted Flags: A dictionary containing the flags that were accepted by the service, with the flag as the key and the corresponding response as the value.</li> <li>Rejected Flags: A dictionary containing the flags that were rejected by the service, with the flag as the key and the corresponding response as the value.</li> </ol> <p>You can adapt the submit function to work with various flag submission mechanisms, such as submitting through a REST API, or over a raw TCP connection. See below for examples.</p> HTTPRaw TCP <pre><code>import requests\ndef submit(flags):\nflag_responses = requests.post('http://example.ctf/flags', json=flags).json()\naccepted_flags = { item['flag']: item['response'] for item in flag_responses if item['response'].endswith('OK') }\nrejected_flags = { item['flag']: item['response'] for item in flag_responses if not item['response'].endswith('OK') }\nreturn accepted_flags, rejected_flags\n</code></pre> <pre><code>from pwn import *\ndef submit(flags):\naccepted_flags, rejected_flags = {}\nr = remote('flags.example.ctf', 1337)\nfor flag in flags:\nr.sendline(flag.encode())\nresponse = r.recvline().decode().strip()\nif response.endswith('OK')\naccepted_flags[flag] = response\nelse:\nrejected_flags[flag] = response\nreturn accepted_flags, rejected_flags\n</code></pre>"},{"location":"user-manual/server/submitter-guideline/#template","title":"Template","text":"<p>If you like type hints, you can use the following template.</p> <pre><code>from typing import List, Tuple, Dict\ndef submit(flags: List[str]) -&gt; Tuple[Dict[str, str], Dict[str, str]]:\naccepted_flags = {}\nrejected_flags = {}\n# Submit and categorize flags\nreturn accepted_flags, rejected_flags\n</code></pre>"},{"location":"user-manual/server/submitter-guideline/#integration","title":"Integration","text":"<p>The script must be placed in the same directory as your <code>server.yaml</code> configuration file. By default, it must be named <code>submitter.py</code>. </p> <p>If you need to name it differently, see the example in the User Manual.</p>"}]}